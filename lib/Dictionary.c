#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "Dictionary.h"
#include "../lib/debug.h"

//  126  ~      is the last nice looking ASCII char
//   32  SPACE  is the first nice looking ASCII char
#define START          (32) // start at SPACE
#define END            (126)
#define ALPHABET_SIZE  (END + 1 - START) // 95 pointers.
// We do not allow the any other characters.

// We'll store 95 * 8 + 8 Bytes per entry plus the part of the
// size of the string entry,
// = 768 Bytes per entry + the part of the strings
// For 200 strings that's 153600 Bytes plus ~ 154 kBytes
// But 

// TODO: We could consider more complex alphabet mapping that uses just
// the characters that are in the strings that we are storing.  Currently
// our mapping from character space to dictionary pointer is a simple
// constant offset.  We may be able to cut memory usage to one third of
// the current, at a relative cost of a more complex character space to
// dictionary pointer mapping.


// A Dictionary via a big fat trie
//
// Faster than a hash table, but eats memory like a pig.
//
// References:
// We use something with less memory than in this:
// https://www.geeksforgeeks.org/trie-insert-and-search/
//
// https://en.wikipedia.org/wiki/Trie
//
struct QsDictionary {

    // A Dictionary node.

    // For our use case:
    //   - We do not need fast insert.
    //   - We do not need remove at all.
    //   - Just need fast lookup.
    //   - This will hold about 1000 elements in extreme cases.
    
    // If there are children than it's an array of length ALPHABET_SIZE.
    // otherwise it's 0.
    struct QsDictionary *children;

    // addString is a string added to the current path traversal
    // generated string.  It can be 0 if no chars are needed.
    //
    // If an insert is done making the addString become incorrect
    // the node must broken into this node will loose as much of the
    // extra characters as it needs to and add children as it needs to,
    // to make all the traversals correct.  This helps us use much less
    // memory, by having more information in a node.
    //
    const char *addString;

    // value stored if there is one.  The key for this value is the string
    // generated by traversing the graph stringing together the character
    // and optional addString (if present) at each node in the
    // traversal.
    void *value;
};


struct QsDictionary *qsDictionaryCreate(void) {

    struct QsDictionary *d = calloc(1, sizeof(*d));
    ASSERT(d, "calloc(1,%zu) failed", sizeof(*d));
    return d;
}


void qsDictionaryDestroy(struct QsDictionary *dict) {

    DASSERT(dict);

    free(dict);
}


// Returns 0 on success or 1 if already present and -1 if it is not added
// and have an invalid character.
int qsDictionaryInsert(struct QsDictionary *node,
        const char *key, const void *value) {

    DASSERT(node);

    for(const char *c = key; *c; ++c) {

        if(*c < START || *c > END) {
            ERROR("Invalid character in key: \"%s\"",
                    key);
            return -1
        }
        if(node->children) {
            struct QsDictionary *parent = node;
            char firstChar = *c;
            node = node->children + ((*c) - START);
            if(node->endOfString) {
                const char *cc = c + 1;
                const char *ee = node->addString;
                for(;*ee && *cc && *ee == *cc; ++cc, ++ee)
                    if(*cc < START || *cc > END) {
                        ERROR("Invalid character in key: \"%s\"",
                                key);
                        // Nothing changed at this point so we can just
                        // return -1;
                        return -1;
                    }
                // CASES:
                //
                // (*ee == '\0')
                // (*cc == '\0')
                //
                // (*ee && ee != node->addString)
                

                if(*ee == '\0') {
                    if(*c)
                        // We can match with the addString
                        continue;
                    // else *ee == *cc == 0 We have a total match.
                    if(node->value) {
                        ERROR("We have an entry with key=\"%s\"",
                                key);
                        return 1;
                    } else {
                        // node->value == 0
                        node->value = value;
                        return 0; // success done
                    }
                }
                if(*cc == '\0') { // There are unmatched chars in addString

                    // We matched part way through the addString.
                    //
                    // So: split the node in two and the first one has the
                    // new inserted value and the second has the old value
                    // and the old children.
                    //
                    // New node children:
                    struct QsDictionary *nnchildren =
                            calloc(ALPHABET_SIZE, sizeof(*nnchildren));
                    ASSERT(nnchildren, "calloc(%d,%zu) failed",
                            ALPHABET_SIZE, sizeof(*nnchildren));

                    // parent -> node1 (firstChar + start of addString) ->
                    //   node2 (ee* + rest of addString) -> ...

                    struct QsDictionary *node2;
                    const char *oldAddString = node->addString;
                    // We make node2 a only child of node with the value and
                    // children of the original node.
                    node2 = nnchildren + (*ee) - START;
                    node2->value = node->value;
                    node2->children = node->children;
                    // node2 just has part of the old addString.
                    if(ee+1) {
                        node2->addString = strdup(ee+1);
                        ASSERT(node2->addString, "strdup() failed");
                    }
                    // Now remake node
                    node->value = value;
                    if(ee == node->addString) {
                        // There where no matching chars in addString
                        // and the char pointers never advanced.
                        free(node->addString);
                        node->addString = 0;
                    } else {
                        // At least one char matched in addString.  Null
                        // terminate the addString after the last matching
                        // char and then dup it, and free the old remains
                        // of addString.  We dupped two parts of this old
                        // addString.
                        *ee = '\0';
                        node->addString = strdup(node->addString);
                        ASSERT(node->addString, "strdup() failed");
                        free(node->addString);
                    }
                    node->children = nnchildren;
                    return 0; // success
                }
                if(*ee && ee != node->addString) {
                    // We match up to "ee" but there is more to go
                    // and we don't match after that.  Result is we need
                    // to add 2 nodes.
                    //
                    // Example:
                    //
                    // Old value at this node:
                    //
                    // "012345" => "012" -> "345" (new node for old value)
                    //     ^
                    //    ee
                    //
                    // and  "012" -> "new node for insert current value"
                    //
                    struct QsDictionary *old = 
                    

                continue;

            }
            node->endOfString = strdup(c);
            ASSERT(node->endOfString, "strdup() failed");
            return 0;
        } else {
            DASSERT(node->endOfString);
            // Make a new array of nodes
            node->children =
                calloc(ALPHABET_SIZE, sizeof(*node->children));
            ASSERT("calloc(%d,%zu) failed",
                    ALPHABET_SIZE, sizeof(*node->children));
            node = node->children + ((*c) - START);
            node->endOfString = strdup(c);
            ASSERT(child->endOfString, "strdup() failed");
            return 0;
        }
    }

    return (void *) value;
}


// Returns element ptr.
void *qsDictionaryFind(struct QsDictionary *dict, const char *key) {


    return 0;
}
